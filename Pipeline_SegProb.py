import argparse
import os.path as ospath
import re
import pickle
from numba import jit
from functools import partial
from multiprocessing import Pool
from os import listdir, mkdir

import numpy as np
from scipy import ndimage
from skimage.feature import peak_local_max
from collections import namedtuple

from utils.ImgUtils import loadstack, save2stack


def imgAllChannel(posID, probDir, dataDir):
    probRe = re.compile(r'{0}_prob.tiff'.format(posID))
    YFPRe = re.compile(r'w\dYFP-YM_{0}.tiff'.format(posID))
    RFPRe = re.compile(r'w\dRFP-YM_{0}.tiff'.format(posID))

    for probFile in listdir(probDir):
        if probRe.match(probFile):
            probStack = loadstack('{0}/{1}'.format(probDir, probFile))
            break
    
    for FPFile in listdir(dataDir):
        if YFPRe.match(FPFile):
            YFPStack = loadstack('{0}/{1}'.format(dataDir, FPFile))
        if RFPRe.match(FPFile):
            RFPStack = loadstack('{0}/{1}'.format(dataDir, FPFile))
    
    return (probStack, YFPStack, RFPStack)

def segProbStack(probStack, threshold = 10):
    counts = np.zeros(len(probStack), dtype=np.int16)
    masks = []
    for idx, img in enumerate(probStack):
        labelOut = ndimage.label(ndimage.binary_opening(img > threshold))
        # labelOut = ndimage.label(img > threshold)
        masks.append(labelOut[0])
        counts[idx] = labelOut[1]
    return masks, counts

def cytoRFPframe(mask, RFPFrame, labelN):
    mask = mask.astype(bool)
    edgeMask = ndimage.binary_dilation(mask) ^ mask
    edgeMeds = RFPFrame[edgeMask]

    return edgeMeds


def cytoRFP(counts, masks, mcStack):
    intesStack = []
    for idx in range(len(masks)):
        # print('running on idx=' + str(idx))
        intesStack.append(cytoRFPframe(masks[idx], mcStack[2][idx], counts[idx]))
    return intesStack


def mainPipe(posID, workDir, tempDir, outDir, probDir, measureFunc=None):
    print('Working on position ID: {0}'.format(posID))
    mcStack = imgAllChannel(posID, probDir, workDir)
    masks, counts = segProbStack(mcStack[0])
    save2stack(masks, '{0}/{1}_SegMask.tiff'.format(outDir, posID))

    measurement = None
    if measureFunc:
        measurement = measureFunc(counts, masks, mcStack)

    return posID, counts, measurement

def generateIDs(probDir):
    idList = []
    probRe = re.compile(r'(s\d+)_prob.tiff')
    for probFile in listdir(probDir):
        if probRe.match(probFile): 
            idList.append(probRe.search(probFile).group(1))
    return idList


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="A script to segment probablity stacks generated by Pipeline_ProbStack, and make measurement. \
        The output will be labeled image stackes and a pickled file of the output.")    
    parser.add_argument("WorkDir", help="The directory containing all the image stacks (only ends with .tiff). Should be generated from Pipeline_ProbStack.py")
    parser.add_argument("-p", "--ProbDir",  default='./pipeline_output', help="The directory for the probility stacks")
    parser.add_argument("-o", "--Output",  default='./pipeline_output', help="The directory for csv output")
    parser.add_argument("-t", "--MultiThread", type=int, default=1, help="Number of thread to use, default = 1")
    parser.add_argument("--temp", default='./pipeline_temp', help="The directory for temp files")

    args = parser.parse_args()

    wDir = args.WorkDir
    probDir = args.ProbDir

    oDir = ospath.normpath(args.Output)
    if not ospath.exists(oDir):
        mkdir(oDir)

    print("Output to " + oDir)

    mtNum = args.MultiThread
    if mtNum == 1:
        multiP = False
    elif mtNum < 1:
        print("Not valid thread number, now working in single thread mode")
        multiP = False
    else:
        multiP = True
    
    tempPath = args.temp
    if not ospath.exists(tempPath):
        mkdir(tempPath)
    pass

    IDlist = generateIDs(probDir)
    if multiP:
        print("Starting {0} threads......".format(mtNum))
        # mainPipeParal = partial(mainPipe, workDir=wDir, tempDir=tempPath, outDir=oDir, probDir=probDir, measureFunc=cytoRFP)
        mainPipeParal = partial(mainPipe, workDir=wDir, tempDir=tempPath, outDir=oDir, probDir=probDir)
        with Pool(mtNum) as p:
            pipeResult = p.map(mainPipeParal, IDlist)
    else:
        pipeResult = []
        print('Single thread mode...')
        for posID in IDlist:
            pipeResult.append(mainPipe(posID, wDir, tempPath, oDir, probDir, measureFunc=cytoRFP))
    
    saveFilePath = '{0}/SegProbOut.p'.format(oDir)
    print('Finished processing, saving at {0}'.format(saveFilePath))

    with open(saveFilePath, 'wb') as f:
        pickle.dump(pipeResult, f)
    print('Scripts finished successfully')